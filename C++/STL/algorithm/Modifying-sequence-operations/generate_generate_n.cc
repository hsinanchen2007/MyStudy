
#include <iostream>
#include <string>
#include <array>
#include <vector>
#include <deque>
#include <forward_list>
#include <list>
#include <set>
#include <unordered_set>
#include <map>
#include <unordered_map>
#include <stack>
#include <queue>
#include <algorithm>
#include <functional>
#include <numeric>
#include <iterator>

using namespace std;

/*

https://en.cppreference.com/w/cpp/algorithm/generate

1) Assigns each element in range [first, last) a value generated by the given function object g.
2) Same as (1), but executed according to policy. This overload does not participate in overload resolution 
unless std::is_execution_policy_v<std::decay_t<ExecutionPolicy>> (until C++20) 
std::is_execution_policy_v<std::remove_cvref_t<ExecutionPolicy>> (since C++20) is true.

Return value
(none)

https://en.cppreference.com/w/cpp/algorithm/generate_n

1) Assigns values, generated by given function object g, to the first count elements in the range beginning 
at first, if count>0. Does nothing otherwise.
2) Same as (1), but executed according to policy. This overload does not participate in overload resolution 
unless std::is_execution_policy_v<std::decay_t<ExecutionPolicy>> (until C++20) 
std::is_execution_policy_v<std::remove_cvref_t<ExecutionPolicy>> (since C++20) is true.


你已经知道可以用for_each()算法将一个函数对象应用到序列中的每一个元素上。函数对象的参数是for_each()的前两个参数所指定序列中元素的引用，
因此它可以直接修改被保存的值。generate()算法和它有些不同，它的前两个参数是指定范围的正向迭代器，第三个参数是用来定义下面这种形式的函数
的函数对象：
T fun (); // T is a type that can be assigned to an element in the range

无法在函数内访问序列元素的值。generate() 算法只会保存函数为序列中每个元素所返回的值，而且 genemte() 没有任何返回值。为了使这个算法
更有用，可以将生成的不同的值赋给无参数函数中的不同元素。也可以用一个可以捕获一个或多个外部变量的函数对象作为 generate() 的第三个参数。
例如：

string chars (30, ' ');// 30 space characters
char ch {'a'};
int incr {};
std::generate (std::begin (chars) , std::end (chars), [ch, &incr]
{
    incr += 3;
    return ch + (incr % 26);})；
std::cout << chars << std: :endl;
// chars is: dgjmpsvybehknqtwzcfiloruxadgjm

变量 chars 被初始化为了个有 30 个空格的字符串。作为 generate() 的第三个参数的 lambda 表达式的返回值会被治存到 chars 的连续字符中。
lambda 表达式以值的方式捕获 ch，以引用的方式捕获 incr，因此会在 lambda 的主体中对后者进行修改。lambda 表达式会返回 ch 加上 incr 
后得到的字符，增加的值是 26 的模，因此返回的值总是在 'a' 到 'z' 之间，给定的起始值为 'a'。这个操作的结果会在注释中展示出来。可以对 
lambda 表达式做一些修改， 使它可以用于任何大写或小写字母，但只生成保存在 ch 中的这种类型的字母。

generate_n() 和 generate() 的工作方式是相似的。不同之处是，它的第一个参数仍然是序列的开始迭代器，第二个参数是由第三个参数设置的元素
的个数。为了避免程序崩溃，这个序列必须至少有第二个参数定义的元素个数。例如：

string chars (30,' '); // 30 space characters
char ch {'a'}/ int incr {};
std::generate_n(std::begin(chars), chars.size()/2,[ch, &incr]
{
    incr += 3;
    return ch + (incr % 26);
})；

这里，chars 中只有一半的元素会被算法设为新的值，剩下的一半仍然为空格。
关注公众号「站长严长生」，在手机上阅读所有教程，随时随地都能学习。本公众号由站长亲自运营，长期更新，坚持原创，专注于分享创业故事+学习历程
+工作记录+生活日常+编程资料。

*/

// below code example is basically from https://en.cppreference.com/w/cpp/algorithm/generate

int f()
{ 
    static int i;
    return ++i;
}

int main()
{
    std::vector<int> v(5);
    auto print = [&] {
        for (std::cout << "v: "; auto iv: v)
            std::cout << iv << " ";
        std::cout << "\n";
    };
 
    std::generate(v.begin(), v.end(), f);
    print();
 
    // Initialize with default values 0,1,2,3,4 from a lambda function
    // Equivalent to std::iota(v.begin(), v.end(), 0);
    std::generate(v.begin(), v.end(), [n = 0] () mutable { return n++; });
    print();

    // generate_n() example
    /*
        std::mersenne_twister_engine
        C++ Numerics library Pseudo-random number generation std::mersenne_twister_engine 
        Defined in header <random>
        template<
            class UIntType,
            std::size_t w, std::size_t n, std::size_t m, std::size_t r,
            UIntType a, std::size_t u, UIntType d, std::size_t s,
            UIntType b, std::size_t t,
            UIntType c, std::size_t l, UIntType f
        > class mersenne_twister_engine;
        (since C++11)
        mersenne_twister_engine is a random number engine based on Mersenne Twister algorithm. It produces 
        high quality unsigned integer random numbers of type UIntType on the interval 
        [
        0
        ,
        2
        w
        )
        .

        Function templates ref() and cref() are helper functions that generate an object of type 
        std::reference_wrapper, using template argument deduction to determine the template argument of the 
        result.

        T may be an incomplete type.

        (since C++20)
        Parameters
        t	-	lvalue reference to object that needs to be wrapped or an instance of std::reference_wrapper
        Return value
        1) std::reference_wrapper<T>(t)
        2) t
        4) std::reference_wrapper<const T>(t)
        5) t
        3,6) rvalue reference wrapper is deleted.
    */

    // generate first 5 random numbers and output them
    std::mt19937 rng; // default constructed, seeded with fixed seed
    std::generate_n(std::ostream_iterator<std::mt19937::result_type>(std::cout, " "),
                    5, std::ref(rng));
    std::cout << '\n';

    // 2022.8.20
    // Above code example needed to use C++ 23 to compile, just for reference

    return 0;
    // v: 1 2 3 4 5 
    // v: 0 1 2 3 4
    // 3499211612 581869302 3890346734 3586334585 545404204
}
