/*
    C++内联函数也可以用来代替宏
    < 上一节下一节 >

    我们在《C语言入门教程》中讲到，宏是可以带参数的，它在形式上和函数非常相似。不过不像函数，宏仅仅是字符串替换，不是按值传递，
    所以在编写宏时要特别注意，一不小心可能就会踩坑。

    使用宏的一个经典例子是求一个数的平方，如下所示：
    #include <iostream>
    using namespace std;
    #define SQ(y) y*y
    int main(){
        int n, sq;
        cin>>n;
        sq = SQ(n);
        cout<<sq<<endl;
        return 0;
    }
    运行结果：
    9↙
    81

    从表面上看这个宏定义是正确的，但当我们将宏调用SQ(n)换成SQ(n+1)后，就会出现意想不到的状况：
    #include <iostream>
    using namespace std;
    #define SQ(y) y*y
    int main(){
        int n, sq;
        cin>>n;
        sq = SQ(n+1);
        cout<<sq<<endl;
        return 0;
    }
    运行结果：
    9↙
    19

    我们期望的结果是 100，但这里却是 19，两者大相径庭。这是因为，宏展开仅仅是字符串的替换，不会进行任何计算或传值，上面的sq = SQ(n+1);
    在宏展开后会变为sq = n+1*n+1;，这显然是没有道理的。

    如果希望得到正确的结果，应该将宏定义改为如下的形式：
    #define SQ(y) (y)*(y)

    这样宏调用sq = SQ(n+1);就会展开为sq = (n+1)*(n+1);，得到的结果就是 100。

    如果你认为这样就万事大吉了，那下面的结果会让你觉得考虑不周：
    #include <iostream>
    using namespace std;
    #define SQ(y) (y)*(y)
    int main(){
        int n, sq;
        cin>>n;
        sq = 200 / SQ(n+1);
        cout<<sq<<endl;
        return 0;
    }
    运行结果：
    9↙
    200

    之所以会出现这么奇怪的结果，是因为宏调用sq = 200 / SQ(n+1);会被展开为sq = 200 / (n+1) * (n+1);，当 n 被赋值 9 后，相当于
    sq = 200 / 10 * 10，结果显然是 200。

    要想得到正确的结果，还应该对宏加以限制，在两边增加( )，如下所示：
    #define SQ(y) ( (y)*(y) )

    这样宏调用sq = 200 / SQ(n+1);就会展开为sq = 200 / ( (n+1) * (n+1) );，得到的结果就是 2。

    说了这么多，我最终想强调的是，宏定义是一项“细思极密”的工作，一不小心就会踩坑，而且不一定在编译和运行时发现，给程序埋下隐患。

    如果我们将宏替换为内联函数，情况就没有那么复杂了，程序员就会游刃有余，请看下面的代码：

    运行结果：
    9↙
    81
    100
    2

    看，一切问题迎刃而解！发生函数调用时，编译器会先对实参进行计算，再将计算的结果传递给形参，并且函数执行完毕后会得到一个值，而不是得到一个
    表达式，这和简单的字符串替换相比省去了很多麻烦，所以在编写C++代码时我推荐使用内联函数来替换带参数的宏。

    和宏一样，内联函数可以定义在头文件中（不用加 static 关键字），并且头文件被多次#include后也不会引发重复定义错误。这一点和非内联函数不同，
    非内联函数是禁止定义在头文件中的，它所在的头文件被多次#include后会引发重复定义错误。

    内联函数在编译时会将函数调用处用函数体替换，编译完成后函数就不存在了，所以在链接时不会引发重复定义错误。这一点和宏很像，宏在预处理时被展开，
    编译时就不存在了。从这个角度讲，内联函数更像是编译期间的宏。

    如果读者不了解编译和链接的细节，请阅读《C语言头文件的编写》一章，我们进行了深入详细的说明。
    综合本节和上节的内容，可以看到内联函数主要有两个作用，一是消除函数调用时的开销，二是取代带参数的宏。不过我更倾向于后者，取代带参数的宏更能
    凸显内联函数存在的意义。


    如何规范地使用C++内联函数
    < 上一节下一节 >

    inline 关键字可以只在函数定义处添加，也可以只在函数声明处添加，也可以同时添加；但是在函数声明处添加 inline 关键字是无效的，编译器会忽略
    函数声明处的 inline 关键字。也就是说，inline 是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。

    尽管大多数教科书中在函数声明和函数定义处都增加了 inline 关键字，但我认为 inline 关键字不应该出现在函数声明处。这个细节虽然不会影响函数
    的功能，但是体现了高质量 C++ 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。

    更为严格地说，内联函数不应该有声明，应该将函数定义放在本应该出现函数声明的地方，这是一种良好的编程风格。

    在多文件编程中，我们通常将函数的定义放在源文件中，将函数的声明放在头文件中，希望调用函数时，引入对应的头文件即可，我们鼓励这种将函数定义和
    函数声明分开的做法。但这种做法不适用于内联函数，将内联函数的声明和定义分散到不同的文件中会出错，请看下面的例子。

    main.cpp 代码：
    #include <iostream>
    using namespace std;
    //内联函数声明
    void func();
    int main(){
        func();
        return 0;
    }
    
    module.cpp 代码：
    #include <iostream>
    using namespace std;
    //内联函数定义
    inline void func(){
        cout<<"inline function"<<endl;
    }

    上面的代码能够正常编译，但在链接时会出错。func() 是内联函数，编译期间会用它来替换函数调用处，编译完成后函数就不存在了，链接器在将多个目标
    文件（.o或.obj文件）合并成一个可执行文件时找不到 func() 函数的定义，所以会产生链接错误。
    如果你对编译和链接的过程不了解，请阅读《C语言头文件的编写》一章。
    内联函数虽然叫做函数，在定义和声明的语法上也和普通函数一样，但它已经失去了函数的本质。函数是一段可以重复使用的代码，它位于虚拟地址空间中的
    代码区，也占用可执行文件的体积，而内联函数的代码在编译后就被消除了，不存在于虚拟地址空间中，没法重复使用。
    如果你对虚拟地址空间或代码区的概念不了解，请阅读《C语言内存精讲》专题。
    内联函数看起来简单，但是有很多细节需要注意，从代码重复利用的角度讲，内联函数已经不再是函数了。我认为将内联函数作为带参宏的替代方案更为靠谱，
    而不是真的当做函数使用。

    在多文件编程时，我建议将内联函数的定义直接放在头文件中，并且禁用内联函数的声明（声明是多此一举）。
*/

#include <iostream>

using namespace std;

inline int SQ(int y){ return y*y; }

int main(){
    int n, sq;
    cin>>n;

    //SQ(n)
    sq = SQ(n);
    cout<<sq<<endl;

    //SQ(n+1)
    sq = SQ(n+1);
    cout<<sq<<endl;

    //200 / SQ(n+1)
    sq = 200 / SQ(n+1);
    cout<<sq<<endl;
    return 0;
}

// 9
// 81
// 100
// 2